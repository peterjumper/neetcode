# [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)

## 題目

Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.

Since the answer may be large, return the answer modulo 10^9 + 7.

 

Example 1:

```c
Input: [3,1,2,4]
Output: 17
Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.
```

Note:

1. 1 <= A.length <= 30000
2. 1 <= A[i] <= 30000


## 題目大意

給定一個整數數組 A，找到 min(B) 的總和，其中 B 的範圍為 A 的每個（連續）子數組。

由於答案可能很大，因此返回答案模 10^9 + 7。


## 解題思路

- 首先想到的是暴力解法，用兩層循環，分別枚舉每個連續的子區間，區間內用一個元素記錄區間內最小值。每當區間起點發生變化的時候，最終結果都加上上次遍歷區間找出的最小值。當整個數組都掃完一遍以後，最終結果模上 10^9+7。
- 上面暴力解法時間複雜度特別大，因為某個區間的最小值可能是很多區間的最小值，但是我們暴力枚舉所有區間，導致要遍歷的區間特別多。優化點就在如何減少遍歷的區間。第二種思路是用 2 個單調棧。想得到思路是 `res = sum(A[i] * f(i))`，其中 f(i) 是子區間的數，A[i] 是這個子區間內的最小值。為了得到 f(i) 我們需要找到 left[i] 和 right[i]，left[i] 是 A[i] 左邊嚴格大於 A[i](>關係)的區間長度。right[i] 是 A[i] 右邊非嚴格大於(>=關係)的區間長度。left[i] + 1 等於以 A[i] 結尾的子數組數目，A[i] 是唯一的最小值；right[i] + 1 等於以 A[i] 開始的子數組數目，A[i] 是第一個最小值。於是有 `f(i) = (left[i] + 1) * (right[i] + 1)`。例如對於 [3,1,4,2,5,3,3,1] 中的“2”，我們找到的串就為[4,2,5,3,3]，2 左邊有 1 個數比 2 大且相鄰，2 右邊有 3 個數比 2 大且相鄰，所以 2 作為最小值的串有 2 * 4 = 8 種。用排列組合的思維也能分析出來，2 的左邊可以拿 0，1，…… m 個，總共 (m + 1) 種，同理右邊可以拿 0，1，…… n 個，總共 (n + 1) 種，所以總共 (m + 1)(n + 1)種。只要計算出了 f(i)，這個題目就好辦了。以 [3,1,2,4] 為例，left[i] + 1 = [1,2,1,1]，right[i] + 1 = [1,3,2,1]，對應 i 位的乘積是 f[i] = [1 * 1，2 * 3，1 * 2，1 * 1] = [1，6，2，1]，最終要求的最小值的總和 res = 3 * 1 + 1 * 6 + 2 * 2 + 4 * 1 = 17。
- **看到這種 mod1e9+7 的題目，首先要想到的就是dp**。最終的優化解即是利用 DP + 單調棧。單調棧維護數組中的值逐漸遞增的對應下標序列。定義 `dp[i + 1]` 代表以 A[i] 結尾的子區間內最小值的總和。狀態轉移方程是 `dp[i + 1] = dp[prev + 1] + (i - prev) * A[i]`，其中 prev 是比 A[i] 小的前一個數，由於我們維護了一個單調棧，所以 prev 就是棧頂元素。(i - prev) * A[i] 代表在還沒有出現 prev 之前，這些區間內都是 A[i] 最小，那麼這些區間有 i - prev 個，所以最小值總和應該是 (i - prev) * A[i]。再加上 dp[prev + 1] 就是 dp[i + 1] 的最小值總和了。以 [3, 1, 2, 4, 3] 為例，當 i = 4, 所有以 A[4] 為結尾的子區間有:  
	
		[3]  
		[4, 3]  
		[2, 4, 3]  
		[1, 2, 4, 3]  
		[3, 1, 2, 4, 3] 
	在這種情況下, stack.peek() = 2, A[2] = 2。前兩個子區間 [3] and [4, 3], 最小值的總和 = (i - stack.peek()) * A[i] = 6。後 3 個子區間是 [2, 4, 3], [1, 2, 4, 3] 和 [3, 1, 2, 4, 3], 它們都包含 2，2 是比 3 小的前一個數，所以 dp[i + 1] = dp[stack.peek() + 1] = dp[2 + 1] = dp[3] = dp[2 + 1]。即需要求 i = 2 的時候 dp[i + 1] 的值。繼續遞推，比 2 小的前一個值是 1，A[1] = 1。dp[3] = dp[1 + 1] + (2 - 1) * A[2]= dp[2] + 2。dp[2] = dp[1 + 1]，當 i = 1 的時候，prev = -1，即沒有人比 A[1] 更小了，所以 dp[2] = dp[1 + 1] = dp[-1 + 1] + (1 - (-1)) * A[1] = 0 + 2 * 1 = 2。迭代回去，dp[3] = dp[2] + 2 = 2 + 2 = 4。dp[stack.peek() + 1] = dp[2 + 1] = dp[3] = 4。所以 dp[i + 1] = 4 + 6 = 10。
- 與這一題相似的解題思路的題目有第 828 題，第 891 題。