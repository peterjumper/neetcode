# [928. Minimize Malware Spread II](https://leetcode.com/problems/minimize-malware-spread-ii/)


## 題目

(This problem is the same as *Minimize Malware Spread*, with the differences bolded.)

In a network of nodes, each node `i` is directly connected to another node `j` if and only if `graph[i][j] = 1`.

Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.

Suppose `M(initial)` is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list, **completely removing it and any connections from this node to any other node**. Return the node that if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.

**Example 1:**

    Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    Output: 0

**Example 2:**

    Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
    Output: 1

**Example 3:**

    Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
    Output: 1

**Note:**

1. `1 < graph.length = graph[0].length <= 300`
2. `0 <= graph[i][j] == graph[j][i] <= 1`
3. `graph[i][i] = 1`
4. `1 <= initial.length < graph.length`
5. `0 <= initial[i] < graph.length`


## 題目大意

(這個問題與 儘量減少惡意軟件的傳播 是一樣的，不同之處用粗體表示。)在節點網絡中，只有當 graph[i][j] = 1 時，每個節點 i 能夠直接連接到另一個節點 j。一些節點 initial 最初被惡意軟件感染。只要兩個節點直接連接，且其中至少一個節點受到惡意軟件的感染，那麼兩個節點都將被惡意軟件感染。這種惡意軟件的傳播將繼續，直到沒有更多的節點可以被這種方式感染。假設 M(initial) 是在惡意軟件停止傳播之後，整個網絡中感染惡意軟件的最終節點數。我們可以從初始列表中刪除一個節點，並完全移除該節點以及從該節點到任何其他節點的任何連接。如果移除這一節點將最小化 M(initial)， 則返回該節點。如果有多個節點滿足條件，就返回索引最小的節點。

提示：

- 1 < graph.length = graph[0].length <= 300
- 0 <= graph[i][j] == graph[j][i] <= 1
- graph[i][i] = 1
- 1 <= initial.length < graph.length
- 0 <= initial[i] < graph.length


## 解題思路


- 這一題是第 924 題的加強版。給出一個節點之間的關係圖，如果兩個節點是連通的，那麼病毒軟件就會感染到連通的所有節點。現在如果想**完全徹底**移除一個病毒節點，能最大減少感染，請問移除哪個節點？如果多個節點都能減少感染量，優先移除序號偏小的那個節點。這一題的輸入輸出要求和第 924 題是完全一樣的，區別在於第 924 題實際上是要求把一個病毒節點變成非病毒節點，而這道題是完全刪除一個病毒節點以及它連接的所有邊。
- 這一題考察的是並查集。當然用 DFS 也可以解答這一題。並查集的做法如下，首先先將所有的病毒節點去掉，然後將所有連通塊合併成一個節點。因為一個連通集合中的節點，要麼全部被感染，要麼全部不被感染，所以可以把每個集合整體考慮。然後統計所有集合直接相鄰的病毒節點的個數。對於一個集合來説：
    1. 如果直接相鄰的病毒節點的個數為 0，則一定不會被感染，忽略這種情況；
    2. 如果直接相鄰的病毒節點的個數為 1，則將該病毒節點刪除後，整個連通塊就可以避免被感染，這種情況是我們尋找的答案；
    3. 如果直接相鄰的病毒節點的個數大於等於2，則不管刪除哪個病毒節點，該連通塊都仍會被感染，忽略這種情況；
- 所以只需在所有第二種連通塊（直接相鄰的病毒節點的個數為 1 的連通塊）中，找出節點個數最多的連通塊，與它相鄰的病毒節點就是我們要刪除的節點；如果有多個連通塊節點個數相同，再找出與之對應的編號最小的病毒節點即可。
